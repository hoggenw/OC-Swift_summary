#一、Xcode中将图片放入assets.xcassets和直接拖入的区别

 * 在mainBundle里面Xcode会生成一个Assets.car文件，将我们放在Images.xcassets的图片打包在里面。这里会有压缩，但是直接拖入（相当于直接将图片放入了mainBundle里面）的不会有压缩，所以程序打包出来会大一点
 * 无论是通过imageNamed:来加载图片，还是直接在Storyboard的UIImageView里面设置图片，并且无论图片是jpg格式还是png格式，都不需要写后缀名；而拖入的图片：如果在Storyboard的UIImageView设置图片，那么需要明确地写上后缀名。（无论是.png还是.jpg都要写）在使用imageNamed:加载图片时，如果是.png格式，则不需要使用后缀名；如果是.jpg格式，则必须要写上后缀名。
 * 放在Images.xcassets的图片不能通过imagesWithContentsOfFile:来加载。（因为这个方法相当于是去mainBundle里面找图片，但是这些图片都被打包进了Assets.car文件）
 * 存放在.xcassets更方便与资源管理，例如更换图片时并需要修改名称，只需要简单的替换图片资源即可。
 * 无需为不同像素的图片分别明明，系统会自动排列并且自动选择相应的图片。

 #二、关于深拷贝和浅拷贝的总结
 
  ### 理解
   * 本质上我认为区别在于复制是是指针复制（浅拷贝）还是复制到新的地址上（深拷贝）

  ### 实际应用(yltest中有具体代码)
  
  	* 大体上会区分为对象和容器两个概念，对象的copy是浅拷贝，mutablecopy是深拷贝。
  	  - 容器包含对象的拷贝，无论是copy，还是mutablecopy都是浅拷贝，要想实现对象的深拷贝，必须自己提供拷贝方法
  	  - 非容器不可变对象：NSString
  	  
  	   ```
  	    1. 对于非容器不可变对象的copy为浅拷贝，mutableCopy为深拷贝
  	    2. 浅拷贝获得的对象地址和原对象地址一致， 返回的对象为不可变对象
        3. 深拷贝返回新的内存地址，返回对象为可变对象
        
  	   ```
  	   
  	  - 非容器可变对象： NSMutableString
  	  
  	  ```
  	   对于可变对象的的拷贝，无论是copy还是mutabelCopy，都为深拷贝，且拷贝后返回的对象也是可变的
  	  ```
  	  - 容器类不可变对象： NSArray

  	  ```
  	  1.容器类不可变对象 copy只是指针copy ，mutableCopy，容器内是地址重新copy是深拷贝
  	  2.但是容器内的对象无论是可变与不可变对象都是浅拷贝
  	     
  	  ```
  	  - 容器类可变对象： NSMutableArray

		```
  	  1.容器类可变对象 copy和mutableCopy是深拷贝
  	  2.但是容器内的对象无论是可变与不可变对象都是浅拷贝
  	     
  	  ```
  	  
  	 ####小结：copy： 对于可变对象为深拷贝，对于不可变对象为浅拷贝； mutableCopy：始终是深拷贝,所谓拷贝，本质上是持有指针（无论是新的地址还是原来的地址）;此外对可变容器赋值时，如果没有使用copy进行赋值，者修改其中一个内容时，其他内容会被修改(思考方向可以从引用指针和引用指针计数上开始)。不可变容器则不受影响.
  	 
  	 ###自定义类对象的深浅拷贝
  	 
  	 在OC中不是所有的类都支持拷贝，只有遵循<NSCopying>才支持copy，只有遵循<NSMutableCopying>才支持mutableCopy。如果没有遵循，拷贝时会直接Crash。
  	 遵守协议以后，无论是copy还是mutableCopy，对于对象而言都是深拷贝；对对象内的属性重新赋值，不会改变其他对象的属性的值，因为赋值本质上来说是赋予新对象的属性指针
  	 
  	 ###关于属性得补充
  	 
  	 ```
     @property (nonatomic ,strong) NSArray *array;
     
		-(void)propertyTest {
    NSArray *array = @[ @1, @2, @3, @4 ];
    NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:array];
    self.array = mutableArray;
    NSLog(@"array :%@, mutableArray: %@,array object_p: %p,object_p: %p",self.array ,mutableArray,self.array ,mutableArray);
    [mutableArray removeAllObjects];
    NSLog(@"array :%@, mutableArray: %@,array object_p: %p,object_p: %p",self.array ,mutableArray,self.array ,mutableArray);
}


  	 ```
  	 
  	 结果
  	 
  	 ```
  	 2018-03-02 11:57:28.028222+0800 YLAudioFrequecy[1446:2312615] array :(
    1,
    2,
    3,
    4
), mutableArray: (
    1,
    2,
    3,
    4
),array object_p: 0x144d8d150,object_p: 0x144d8d150
2018-03-02 11:57:28.028532+0800 YLAudioFrequecy[1446:2312615] array :(
), mutableArray: (
),array object_p: 0x144d8d150,object_p: 0x144d8d150
  	 ```
  	 如果没有使用[mutableArray copy]（深拷贝）;而直接使用self.array = mutableArray;因为实际上array是被赋值了mutable属性；
  	 移除时值会被消除；
  	  
  	  
  	  